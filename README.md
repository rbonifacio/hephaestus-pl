Hephaestus-PL
=============

Hephaestus-PL is a product line (hence _PL_) which supports generation of tools taylored to specific product derivation needs. It supports a transformational approach to product derivation, whereby one can apply flexible transformations over artifacts in order to resolve variability and create concrete solutions.

So if you have a product line and the need for handling variability of use case scenarios, you can have a tool to cope with that. Variability on business process models? We have that, too. In need of both? Sure, tell Hephaestus-PL the kinds of assets you have and it will build a new Hephaestus for you to manage them.

Do you need source code and end-user documentation management? Yes, we saw that coming... unfortunately, we don't support these yet, but you can make use of Hephaestus' extensible architecture to add it. Thereon you can generate a product derivation tool with support for any combination of those artifacts.


How does it work?
-----------------

### Setting up the environment

Hephaestus-PL stands on the shoulders of [Haskell][haskell-lang], a purely functional language with a powerful type system, which helps on achieving robustness, terseness and readability of code at the same time. To build it, you'll need some Haskell tools:

- A compiler. **GHC** is the _de facto_ standard, and we have built Hephaestus-PL with its 7.6.3 version.
- Haskell's package manager, **cabal**.

Then you have to install Hephaestus-PL's dependencies:

```bash
$ cabal install bimap
$ cabal install bitset
$ cabal install parse-dimacs
$ cabal install hxt-relaxng
```

If you want to build derivation tools with support for FDTMCs, you will also need these packages:

```bash
$ cabal install hatt
$ cabal install fgl
$ cabal install graphviz
```

```bash
$ cabal install syb
$ cabal install MissingH
```

**TODO:** Add some straight-to-the-point compilation instructions. Preferably a build script or cabal configuration file.

### Configuring and building a tool

Once you have your environment set, to build a tool you must tell Hephaestus-PL which kinds of artifacts you want to handle. This is currently done writing a few lines of Haskell code to define a module which depends on the features you are asking for. This module must be created at `src/meta-hephaestus/HplDrivers`, where you can find some examples of existing configurations.

To generate your tool, you then need to compile and run the newly created driver module. To aid this task, you can

```bash
cd src/meta-hephaestus
make <YourConfigurationDriverName>.drive
```

This step will generate a file `src/meta-hephaestus/HplProducts/Test.hs`, which is precisely your new tool's main module, just waiting to be compiled. Yes, _Test_ is not a very intuitive name, but we're working on it. Let's not lose focus here, ok?

To build it, do `make generatedHephaestus NAME=<AwesomeHephaestusInstance>`, and you will have an executable file `src/meta-hephaestus/HplProducts/AwesomeHephaestusInstance`.


Ok, I built a new tool. How to use it?
--------------------------------------

A new tool &ndash; a Hephaestus instance &ndash; takes a configuration file as input and generates a product by:

- verifying the _instance model_ (i.e, the feature selection) satisfies the constraints specified by the _feature model_; and
- applying transformations selected by cross-checking the _instance model_ and the _configuration knowledge_ over the _asset base_.

The configuration file is specified using _properties_ notation, with which you assign file paths to variables representing the configuration assets needed by your Hephaestus instance. Those will vary with the Hephaestus' configuration, but you will have to feed it at least the following information concerning your product line configuration assets:

- `name` - the name of the product-to-be.
- `feature-model` - the path to your product line's _feature model_. It must be an XML file generated by the [Feature Modelling Plugin][fmp], but we have plans to support [Feature IDE][feature-ide]'s format soon.
- `configuration-model` - a configuration knowledge specified with Hephaestus' own XML dialect. You can see some examples at `src/meta-hephaestus/HplProducts/samples`.
- `instance-model` - the _feature selection_ for this product. Currently needs to be an XML representing a subtree of the _feature model_.
- `target-dir` - the output directory where the transformed assets will be placed.


How can I support a new kind of asset?
--------------------------------------

To add support for handling new kinds of assets, you must create new modules at `src/meta-hephaestus/HplAssets` with:

- definition of data types for the data structures which represent your assets in memory;
- definition of transformations over those data structures;
- a parser function for turning the physical assets into the aforementioned data structures; and
- a pretty-printer function for doing the inverse &ndash; turning data structures into files.

Then you must tell Hephaestus-PL those new modules exist and configure how they plug into the existing framework.

**TODO:** Add some details of how to do this.


[fmp]: http://gsd.uwaterloo.ca/fmp
[feature-ide]: http://wwwiti.cs.uni-magdeburg.de/iti_db/research/featureide/
[haskell-lang]: https://www.haskell.org/haskellwiki/Haskell
